{
  "name": "Xemu",
  "tagline": "Somewhat lame emulation (running on Linux/Unix/Windows, utilizing SDL2) of some 8 bit machines, including the Commodore LCD and Commodore 65 (later with SOME Mega65 features as well).",
  "body": "# X-Emulators\r\n\r\n[![Gitter](https://badges.gitter.im/lgblgblgb/xemu.svg)](https://gitter.im/lgblgblgb/xemu?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\r\n\r\nEmulations running on Linux/Unix/Windows/OSX of various (mainly 8 bit) machines,\r\nincluding the Commodore LCD and Commodore 65 as well.\r\n\r\nWARNING: there is *nothing* too much common in these machines. The only reason\r\nthat I emulate these within a single project, that I can easily re-use some\r\nof the components needed, that's all!\r\n\r\nFor some story line: http://cubed-borka.blogspot.hu/2016/05/my-commodore-65-and-commodore-lcd.html\r\n\r\nCommodore LCD is a highly unknown portable LCD based device with battery power and\r\nability to \"sleep\" with SRAMs still powered. Unfortunately the project was stopped\r\nbefore the production phase, only about 2-5 units known to exist in different state\r\nof development. Compared to the LCD, Commodore 65 is a highly known, well documented,\r\neasy to get and wide-spread machine :)\r\n\r\nI spent lot of work to get know the basic (then detailed) information on this nice\r\nmachine, enough, to be able to write an emulator. Intially not even the basic facts\r\nwere available (what kind of CPU, clock frequency, etc). I've managed to get enough\r\ninformation (from disassembly of the available ROM images, debugging my emulator,\r\nand some cases by asking ex-Commodore ex-engineers). The result was a specification\r\nand a JavaScript based emulator.\r\n\r\nhttp://commodore-lcd.lgb.hu/\r\n\r\nIt was some years ago, and though a native emulator is developed (not made as a\r\npublic release) it was buggy, it used quite questionable SDL screen \"updating\"\r\nsolution etc. Now it's a fresh start, with reusing the CPU and VIA emulation parts\r\nonly.\r\n\r\nThis piece of code is about writing a native emulator version which can be run\r\nat least on Windows and Linux (or Unix-like machines, Raspberry PI is included)\r\nwith the help of the SDL2 library. Note, that in theory, it would be easy to\r\nport to other targets because of using SDL.\r\n\r\nAs I wanted to emulate other machines as well, I renamed the project from XCLCD\r\n(CLCD = Commodore LCD) to \"X-Emu\".\r\n\r\n## Basic usage of the emulator\r\n\r\nCurrently no data storage is implemented ... You basically have only two hot-keys\r\ndefined, press F9 to exit, or F11 to toggle between windowed and full screen mode.\r\nThat's all.\r\n\r\nOtherwise, you should be able to use your keyboard to \"type\" as it would be the\r\nkeyboard of the real machine. However, please note: keyboard layout is SDL scancode\r\nbased! That is, maybe it's nothing about the letters on your PC keyboard :)\r\nespecially if you use some national (and not US) keyboard layout. As there are tons\r\nof layouts out there, it would be hard to do otherwise ... Though symblic mapping\r\ncan be a solution, but shift difference (ie, a key is shifted on PC, but not on the\r\nemulated machine or vice versa) would cause problems. The only exception here is\r\nCommodore VIC-20 shifted cursors. It should work without shift too (with the four\r\ncursor keys), however exactly because the emulated shift, it's possible that shift\r\nis not detected, as it's only \"pressed\" virtually at the same time as the key itself.\r\n\r\nOn Windows, you need SDL2.dll (included in the distributed package). You also need\r\nthe ROM images.\r\n\r\n## About SDL rendering - please help me :)\r\n\r\nLet me explain one thing: if you're more in SDL2 internals than me, please contact\r\nme. I feel quite lost (with my \"more serious\" emulator too, Xep128, also on github)\r\nabout the \"ideal\" solution to render an average 8 bit computer's screen. That is\r\nusually we have 256 or less (16 in case of VIC-20, and only two in case of Commodore\r\nLCD) colours. That is, an indexed method would be ideal. I've tried to use that and\r\nit seems it's unstable, and even not usable on some platforms. At the end, I've found\r\nmyself in the situation, that I should render RGBA pixels as DWORDs as a streaming\r\ntexture. It seems to be quite OK. However, just a quick peek on other emulatorts\r\nusing (\"only\" or \"also\") like FUSE (ZX Spectrum emulator) or Hatari (Atari emulator)\r\nit seems they use SDL surfaces. Honestly, I can't even see the difference between\r\nthese notions and the precise impact ... Using textures seems to have acceptable\r\nperformance even in full screen/scaled mode, even on a quite \"weak\" hardware as\r\nRaspberry Pi model 1 is! So maybe it's not even needed to lamenting a lot on this\r\nissue, however I'm still curious the scene at the background behind this topic.\r\nAlso, using DWORDs by pixel seems to be overkill, but it's possible that today's\r\ncomputer are not so optimized in 8 bit writes anyway during updating the pixel\r\nbuffer / texture, so using DWORDs by pixel cannot be a big problem. Also I am not\r\nso sure what is the \"ideal\" format to be used (for best performance, for me it\r\nseems `SDL_PIXELFORMAT_ARGB8888` is, with constant 0xFF for the alpha channel - but\r\ndo not forget that solution should be platform independent somewhat ...).\r\n\r\nWhat I think: my solution can't be *so* bad, as it works (testes) at least on Linux,\r\nWindows, and Raspberry Pi, with quite acceptable performace. However being as\r\na \"maximalist\" I always have the thoughts that it can be better, maybe :)\r\n\r\nemutools.c is aimed to be a simple \"layer\" for an average emulator-like project,\r\nso I've tried to put everything unrelated to the given emulated machine there.\r\nIncluding the SDL stuffs, of course.\r\n\r\nPlease don't hesitate to contact me, if you have an constructive opinion. Thanks!\r\n\r\n## The missing bits\r\n\r\nStill many work is left. Honestly, I feel, it would be better to be included in\r\nVICE, however I am lame to even understand *some* of the VICE internals ... But\r\nVICE has already quite exact 65C02 (well, I guess it has that too, not only\r\n6502, hmm ...), VIA, disk drive ... whatever emulation. Just it would be needed\r\nto be \"wire\" things together.\r\n\r\nFor both emulators, the major problem is the lack of any storage solution, or\r\nat least the ability to load programs.\r\n\r\nOf course audio emulation would be nice as well (LCD had *some* audio, also\r\nthe VIC-20, for sure).\r\n\r\nAbout further problems with VIC-20 (please note: VIC-20 is currently not the\r\nmajor character of the show, much better emulators exists for that nice little\r\nmachine!).\r\n\r\n## Commodore 65 emulator??\r\n\r\nYes. Or kind of ... Quite limited currently though. For me, it worked to the\r\nlevel for BASIC prompt, and even for typing commands, or switching to C64\r\nmode (GO64), or you can try write BASIC programs (NOTE: ROM 911001.bin seems\r\nnot to work properly, but 910111.bin does).\r\n\r\nWhat is emulated and what is not:\r\n\r\n* 65CE02 \"core\" instructions, hopefully more-or-less correctly emulated.\r\n  65CE02 emulation is done by extending/modifying a 65C02 emulator (of mine)\r\n  since 65CE02 is basically an extended 65C02, with only \"some\" differences\r\n  (oh, yes, \"some\" ... well).\r\n\r\n* 4502 \"core\" extensions over 65CE02, ie MAP opcode, and special meaning\r\n  of NOP (as EOM)\r\n\r\n* Though in theory 65CE02 does not use the old NMOS behaviour of RMW\r\n  opcodes (ie, write twice), it introduces incompatibilties with C64 software.\r\n  As it seems, Mega65 already uses the \"old behaviour\" for more compatibility,\r\n  I try to follow this path as well.\r\n\r\n* Memory management: CPU \"MAP\"/\"EOM\" stuff, VIC3 register $30 ROM select\r\n  and 2K colour SRAM mode, \"C64-style\" \"CPU port\". REC is not emulated.\r\n\r\n* DMAgic COPY/FILL should work, MIX/SWAP is only guessing. Modulo is not\r\n  supported (and not so much information is available how it should work\r\n  anyway, as with case of MIX).\r\n\r\n* 128K ROM / 128K RAM. Optionally (enabled by default) 512K RAM emulated in\r\n  the upper region, though not in a REC compatible way. This even can cause\r\n  problems, I guess.\r\n\r\n* FDC emulation may be used to *read* D81 disk images, but still there are bugs!\r\n  Currently, the FDC part is the most ugly in source. SWAP bit is not emulated,\r\n  which can cause even data corruptions (\"fortunately\" since everything is\r\n  read-only, there is no chance to corrupt the disk image content itself).\r\n\r\n* VIC3 code is horrible, it merely emulates full frames in one rendering\r\n  step only. Many things are not emulated: MCM/ECM for classic VIC2 modes,\r\n  no border, no DAT, no hardware character attributes, no V400\r\n  and interlace, and no H1280 mode. Though bitplane modes, programmable\r\n  palette, 40/80 column text mode, and classic VIC2 hires mode should work.\r\n  K2 demo is able to show the \"busty woman\" already with my emulator.\r\n\r\n  Sprites are emulated in a *very* lame and limited way. Multicolour\r\n  sprites are not supported, and even the \"under the screen\" priority\r\n  is not handled. Sprites in bitplane mode are incorrect now. Also, the\r\n  \"render a frame in once\" scenario makes sprite multiplexing or any other\r\n  tricks impossible. Sprite emulation is mainly included only for some\r\n  simple tasks, ie \"mouse pointer\" in certain softwares, and for similar\r\n  usages.\r\n\r\n* There is *some* SID emulation, but it's horrible, believe me :)\r\n  Two SIDs are emulated with the help of SID emulation core from\r\n  'webSID' (see sid.c for more details). However the major problem is,\r\n  that SID \"audio rendering\" is only done currently, if audo buffer\r\n  is needed to fill. Moreover, the exact timing is nowehere in\r\n  my implementation - I guess - compared to the original. Forgive me,\r\n  I'm the lamest in the audio realm ...\r\n\r\n* No emulation for the UART, REC (Ram Expansion Controller)\r\n\r\n* CIA emulation (for real, part of 4510 and not even full CIAs from\r\n  some aspects) is quite lame. Though it seems enough for keyboard and\r\n  periodic IRQ generating in C64 mode at least\r\n\r\n* Keyboard is not fully implemented (not the extra keys like TAB - it seems\r\n  it's handled by - surprisingly - by the UART part ...), and\r\n  some mapping problems (ie, position based mapping for US host machine layout,\r\n  some keys are still missing, I was lazy ...).\r\n\r\nCompatibility:\r\n\r\n* First \"milestone\" is already here, it can \"boot\" to BASIC, though :) Now, it\r\n  also does its work with \"DIR\" command, if D81 image is given.\r\n\r\n* C65 standard boot is OK\r\n\r\n* C64 mode can be used (\"GO64\")\r\n\r\n* GEOS kernal can be booted, the \"chessboard\" background can be seen\r\n\r\n* K2 demo is able to show the \"busty woman\" (320x200 256 colours, 8 bitplanes\r\n  mode)\r\n\r\n* IFF demos has problems currently, I am not sure what is the problem\r\n  yet (though there is a modified version on an FTP site - saying it should\r\n  work and fixed - it is able to show at least the \"King Tut\" picture)\r\n\r\nBasic usage of the emulator:\r\n\r\n* You need to give the disk image (should be D81 in format!) name as the\r\n  parameter of the executable, if you want disk access.\r\n\r\n* Press F11 to toggle between window/full screen mode\r\n\r\n* Press F10 to RESET.\r\n\r\n* Press F9 to exit\r\n\r\nThat's about all - currently :)\r\n\r\n## What is that \"Commodore GEOS\" emulator?!\r\n\r\nIt's a very primitive Commodore 64 emulator without many features and with\r\nthe intent to have special support to run *OWN* GEOS version interacts with\r\nthe emulator in a special way. It's a help/debug tool for some GEOS\r\nrelated projects. Probably you don't ever need this emulator currently,\r\nand only useful for myself :) And no, please don't ask the \"special GEOS\r\nversion\" ...\r\n\r\n## Why the Commodore VIC-20 emulation is included?\r\n\r\nForeword: this VIC-20 emulator is incomplete, unfinished, and very incorrect,\r\neven the CPU type is not what a real VIC-20 used! You really don't want to use\r\nthis emulator as your main VIC-20 experience :)\r\n\r\nThe reason of this emulator: it's a great test bed for Commodore LCD emulation.\r\nCommodore VIC-20 is a much more known machine, and basically also uses the\r\nVIAs as the Commodore LCD. Commodore VIC-20 is proven to be able to use serial\r\nIEC bus, while I have/had (?) problems with that with Commodore LCD emulation.\r\nThus, if I can do it well on a Commodore VIC-20 emulation, I can say, I do it\r\nwell, so I can try to hook the IEC part to the Commodore LCD emulation. And so\r\non. Also, VIC-20 is a \"simple\" machine enough to emulate, compared eg to a\r\nCommodore 64 (which would also need CIAs and not VIAs to be emulated).\r\n\r\nOther reason: my \"more serious\" emulator (Xep128, also on github) is about\r\nbeing just too complex to \"play\" with it for \"quick modifications\" to try\r\nthings out about the basics of writing emulators (ie using SDL, the timing\r\ncode, in the future: audio sync, etc). It seems it's better to do it here,\r\nwith more simple emulators, and using the results in the Xep128 project as\r\nwell.\r\n\r\nAbout the CPU: since Commodore LCD uses software compatible CPU (exact type is\r\nnot very known) of 65C02, my experimental VIC-20 emulator also uses that!\r\nThat's a direct attack against poor VIC-20 :) as it used 6502! So, of course\r\nthings like illegal opcodes won't work using my emulator!\r\n\r\nFull (?) list of stupidities of my VIC-20 emulator:\r\n\r\n* 65C02 as the CPU, not 6502 (no illegal opcodes), this is by intent!\r\n* Exact screen origins, timings are not exact\r\n* Scanline based emulation, parameters can only change after a whole scanline\r\n* No sound is emulated\r\n* No tape, or serial IEC bus is emulated (floppy drive)\r\n* NMI handling, RUN/STOP + RESTORE does not work\r\n* Only \"PAL\" system is emulated\r\n* VIA emulation is unfinished, and maybe quite inaccurate as well\r\n\r\nSome extra features of Commodore VIC-20 emulator (compared to Commodore LCD):\r\n\r\nCommand line options:\r\n\r\n@1 @8 @16 @24 @40\r\n\r\n@1 @8 @16 @24 @40 -\r\n\r\n@1 @8 @16 @24 @40 something.prg\r\n\r\nThe '@' options configures the memory expansions at the given kilobyte.\r\nOf course you can specify less (or none) of them.\r\n\r\nThe '-' option causes to \"boot\" into monitor mode. The monitor is currently\r\nunusable, only 'x' (exit) command works :)\r\n\r\nIf some filename is given (ie not start with '@' or '-') it tried to be\r\nloaded and auto-started, as a BASIC program (or ML one, with BASIC 'stub').\r\n\r\nNo filename or '-' causes to boot into BASIC.\r\n\r\nNOTE: currently no check about illegal .prg, which would exceed the available\r\nconfigured RAM, or even overwriting ROM with bogus start address with the\r\ntwo first bytes, etc. Also, it's possible that the program requires other\r\nmemory configuration, so the BASIC start is different, this is not handled\r\nautmatically either ...\r\n\r\nFunctionality of auto-load (currently the only way to load a program ...)\r\nrequires the emu ROM to be usable, you can find it in the rom/ directory.\r\n\r\nYou can use numeric key pad arrow keys as the \"joystick\", \"5\" is the fire.\r\nOptionally, you can use the right CTRL of keypad button '0' for fire too.\r\n\r\nYou can try to use a supported Game Controller / Joystick as well (I've\r\ntested with XBox-360 controller). Currently, there is no mapping of controls,\r\nwhich can be a *big* problem. Only axes 0/1 can be used as the joystick,\r\nbut it's hard to tell, which controls they are on *your* joystick (maybe even\r\nvertical/horizontal is mixed ...), or the \"hats\" can be used as well. Every\r\nbuttons are used as the \"fire\" button.\r\n\r\n## Getting the ROMs\r\n\r\nFor all compilation and usage options needs ROMs to be able to use the\r\nemulators. For that purpose, download those yourself, or if it's OK to allow\r\nmake to do the work, you can say: `make roms`. This will download ROM images\r\nfrom the Net.\r\n\r\n## Compilation on Linux / UNIX-like machine\r\n\r\nNote: I tested this on Linux only. You should have sdl2 _development_ libraries\r\ninstalled (at least version 2.0.4 is needed), along with gcc, GNU make (probably\r\nBSD make won't work). Then the only thing you need is saying: `make`\r\n\r\nResulting binaries will have the \"extension\" of .native, but you can forgot\r\nthat of course, it's just for the ability to be able to build for multiple\r\narchitectures (ie for Windows it will have .win32).\r\n\r\n## Compilation for Windows\r\n\r\nTo be able to compile emulators for Windows, you must have a Linux (or probably\r\nother UNIX-like system) with suitable cross-compiler able to generate Windows\r\nbinaries. You also need the SDL2 (at least 2.0.4) stuffs installed, and\r\nbuild/Makefile.win32 is possible modified for proper settings.\r\nYou can also decide to try to build for win64. About the same applies to that\r\narchitecture, however every mentioned `win32` should be replaced with `win64`.\r\nAlso, you need the SDL2 for win64 in that case, also the development environemnt\r\nand of course the DLL itself too.\r\n\r\nThen you can say: `make ARCH=win32`\r\n\r\nThe result will have the extension .win32, but actually it's an .exe :)\r\n\r\n## Compilation for OSX\r\n\r\nSince OSX is UNIX in its heart, it's about the same theory as `native` architecture\r\n(that is, \"Linux / UNIX-like\"). However since it seems (at least on Travis build\r\nenvironment) the default gcc (which is langc for real ...) does not know some\r\noptions, I used another architecture option, namely `osx`.\r\n\r\nFirst, you need the usual SDL2. Maybe the most easy way is to use Homebrew.\r\nTo learn mode about this, visit this page: http://brew.sh/\r\n\r\nYou need to install SDL2:\r\n\r\n`brew install sdl2`\r\n\r\nThen, you can try to compile the emulators:\r\n\r\n`make ARCH=osx`\r\n\r\nThe result binaries will have the extension `.osx` but it does not mean too much,\r\nthey're just my notion here.\r\n\r\n## General compilation related notes\r\n\r\nLink-time-optimalization (lto, see -flto gcc switch) seems to be kinda picky.\r\nYou may want to give the optimization flags at the linker stage to! Also:\r\ngo *not* mix -g switch (eg you want to debug the program with gdb) with -flto\r\naccording to the gcc manual, it can cause very odd problems! Basically you\r\nshould change DEBUG setting in Makefile from -flto to -g, if you want to debug.\r\n\r\nArchitecture specific (ie win32 or native) settings are in the build/ directory!\r\nIncluding the used C compiler path, flags, sdl2-config path, etc ...\r\n\r\nIf you add/remove files, include new header files, etc, you should say `make dep`\r\nfor the given architecture selected.\r\n\r\nIf you want to compile a *single* target only (let's say Commodore 65), just\r\nchdir into the directory of the target, and say `make` there (with the possibility\r\nof ARCH=... part of course. Still, the executable will be built in the directory\r\n~/build/bin relative to the top level.\r\n\r\n## Compilation for Raspberry Pi\r\n\r\nYou have two choices. You can compile it on the Raspberry Pi itself, then you need\r\nto follow instructions given in the \"Compilation on Linux / UNIX-like machine\"\r\nsection.\r\n\r\nYou'll need SDL version 2.0.4 (or newer, if any ...), then you will be able to\r\nrun the emulators directly from text console, no X11 GUI is required at all :) Which\r\nmeans lower resource usage, of course. I've not tested the stuff on Raspb.PI on\r\nX11!\r\n\r\nAlso, you can use a cross-compiler on your desktop machine, if it's a Linux/UNIX\r\nkind of machine. This option is under development though, and isn't made available!\r\n\r\nSome notes:\r\n\r\nAccording to my experiments -falign-functions=16 -falign-loops=16 really\r\nhelps on Rapsberry-Pi at least.\r\n\r\n*Latest test: about 19% CPU usage on a good old Raspberry Pi model 1 for the\r\nCommodore VIC-20 emulator. Not bad ... For the Commodore 65 emulator, it is not\r\nfair to do any test yet, since the emulator does literally hundreds of log messages\r\nby second which slows down the emulation a lot, even if that is redirected into\r\n/dev/null (involves syscalls, etc).*\r\n\r\nIt's interesting to play with locked texture access compared to the non-locked\r\nversion. On my PC, the difference cannot even be seen too much. However it's\r\nquite possible that on a lower performance hardware the difference can be seen\r\nmore. Basically, the locked method seems to be the suggested one, however I'm\r\nstill not sure, any feedback is welcome!\r\n\r\nFor more information from me (it also contains tips for SDL compilation\r\non the Raspberry PI itself):\r\n\r\nhttps://github.com/lgblgblgb/xep128/wiki/Raspberry-Pi\r\n\r\nThen you need to run xvic20 directly from a text console, not in X11!\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}